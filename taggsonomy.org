Taggsonomy
* Taglines
** Tagging it seriously
** Tags done right.
** Tag the World!
** The labelmaker you won't wanna regift
* Nomenclature
** Tags vs. labels :private_v_global_tags:
… maybe for the distinction between global and private tags?
** Tag sets
A taggable object has a one-to-one relation to a tag set object, which is said to "contain" tags (i.e. it has a many-to-many relation to tag objects).
A tag set can also implement some logic (e.g. removing tags excluded by newly added tags, cf. Exclusions), so it's a useful abstraction in that sense, too.
* Tag relations
** Exclusions (mutually exclusive tags)                                 :MVP:
:PROPERTIES:
:Milestone: 0
:END:
"A excludes B"
- Note that "A excludes B" implicitely also means "B excludes A", but the code should make this explicit.
- In this situation, adding tag "B" to an object that already has tag "A" will silently remove tag "A".
** Inclusions (Subtags and Supertags)                                   :MVP:
:PROPERTIES:
:Milestone: 0
:END:
If there's a tag "Programming" and a tag "Python", then it might make sense for all objects tagged "Python" to also be tagged "Programming".
In fact, a user might want to automate this in some way. That's what inclusions are for. We can let "Programming" *include* "Python" and then each object tagged "Python" will also be tagged "Programming".
Practically, this means that if "Python" is included by "Programming" then adding the tag "Python" to any tag set will automatically also add "Programming" to it.
We call "Programming" a *supertag* of "Python" and "Python" a *subtag* of "Programming".
Each tag can be a supertag, subtag, none or both.
*** Renaming this feature
Originally, I implemented this such that the subtag "included" the supertag, i.e. you would call `subtag.include(supertag)`.
From an implementation standpoint this seemed to make sense, since adding the subtag to a tag set also "pulls in" (thus, "includes") the supertag.

But that makes the nomenclature misleading, because if you implement it this way you'd end up having to say: "The tag 'Python' includes the tag 'Programming'.", which runs contrary to common usage where the *topic* 'Programming' includes the topic 'Python'.
I decided to, essentially, reverse the meaning to conform to expectations.

So if I have
```
supertag = Tag('Programming')
subtag = Tag('Python')
```
I should then call `supertag.include(subtag)`, `supertag.includes(subtag)` shoudl return `True` and adding `subtag` ("Python") to a tag set should also add `supertag` ("Programming") to it.
*** Circular inclusions should not be allowed
… as they would lead to all kinds of problems (inclusion graph not directed anymore) and has no conceivable benefit for the user (all tags in a closed inclusion circle are functionally identical)
*** Tags with mutually exclusive supertags
… are a problem and should not be allowed, because when adding such a tag to a tag set, it is unclear which of the mutually exclusive supertags to "pull in".
*** Should inclusion of a (new sub)tag automatically add the new supertag and its supertags to all tag sets already containing the subtag?
In other, more concrete, words: Say I already have a tag "Python" and a bunch of objects tagged with it and now I decide to create a new tag "Programming" and make it a supertag of "Python", should all objects tagged with "Python" automatically get tagged with "Programming"?
If so, there is one problem: What if any of those tagged objects is tagged with some tag that's excluded by one of the supertags to be added? Let's say, for example, that there's a tag named "Management" that's mutually exclusive with "Programming" and that an object exists that is tagged with both "Python" and "Management", a perfectly valid situation.
Left unchecked, the base behaviour would be to silently remove the old tag "Management" the moment the new supertag that excludes it ("Programming") gets added. This would come as a surprise to a user who might not expect or predict this behaviour and it also constitutes a loss of information, as the object can no longer be found under "Management". Thus it's unacceptable.
I would say that updating tagged objects in this way should be user configurable and off by default.
So there should be an option like "update tagged objects", or similar, and it should default to "No".
Furthermore, if the option *is* selected, it should be checked whether adding the new supertags /would/ remove an existing tag from a tag set, due to exclusion, and the operation should fail if that's the case.
We might think about including a /second/ option like "silently remove excluded tags", or similar, only to be shown when the first option is selected, which would allow the operation to go through.
*** Inclusion by tag groups                                      :tag_groups:
:PROPERTIES:
:Milestone: 1
:END:
If a subtag is included by a group tag, then when the subtag is added to a tag set, it "pulls in" all the tags in the group.
Except if the tag group consists of mutually exclusive tags, then it becomes harder to figure out which one of the tags in the group to add.
Basically, we cannot decide this automatically in this case and need help from the user.
** Ordering                                                             :MVP:
:PROPERTIES:
:Milestone: 0
:END:
- "A > B"
- Only meaningful for mutually exclusive tags.
- Allows sorting by related tags
- Difficult to maintain consistent ordering without tag groups, since each tag could only give its own ordering relation to other tags. Overall, ambiguous or nonsensical orderings (e.g. loops) may emerge.
** Tag transition rules                                    :transition_rules:
"If tagged with A, cannot tag with B"
- only meaningful with mutually exclusive tags.
- Similar consistency considerations as for tag ordering apply
* Advanced features
** Tag groups                                                    :tag_groups:
:PROPERTIES:
:Milestone: 1
:END:
Allow mutually exclusive tags with consistent ordering and consistent transition rules.
- Basically implement all of the individual tag features in a convenient package.
- Maybe make implementation transparent:
  - New tag without any relations forms its own tag group "behind the scenes", when relations are added the group becomes explicit.
** Private vs. global tags
There should be a difference in graphical representation, i.e. a small globe icon at the left of the tag name for global tags and a little lock or person icon for private tags.
*** Global tags
globally unique (per system)
*** Private tags
only unique per user, duplicates (by name) can exist, but are of course completely separate objects
*** Group tags? :private_v_global_tags:
** Tag-based visibility / access control?
E.g. only objects with global/admin level tag "X", "user:X" or "group:x" are visible to user(s in group) "X"
** Tags for structured meta-data? :structured_metadata_tags:
… like dates, coordinates, annotations, people etc.
Basically, generic object (key/value) store.
[[https://orgmode.org/manual/Properties-and-columns.html#Properties-and-columns][Org-mode calls these "properties".]]
*** Alternative names
**** Complex tags
**** Composite tags
*** Format
Colon as separator, could only be a convention, but could also trigger some additional processing in the background, e.g. validation, ordering etc.
*** Examples
**** "birth date: 1970-01-01" or "version: 1.0.1" :alphabetic_sorting:
… with additional validation applied to the "second field" (value) and optionally even sorting.
Note that in these examples alphabetic sorting of (presumably mutually exclusive) tags would do the trick.
**** "actor: John Doe", "director: Jane Doe"
Note that this example could not be accomplished by combining the tags "actor", "director", "John Doe" and "Jane Doe", since it's not clear which job title refers to which person.
**** "episode: 05", "season: 02"
**** "preceded by: <object>", "followed by: <other object>", "greater than: <object: foo>"…
These are basically object relations. Could be one-to-one, one-to-many or many-to-many.
Backwards relations need to be defined so they can be implemented automatically.
Now we're really getting into object DB territory, I wonder whether this is still a good idea…
***** TODO research RDF and related technologies (Wikidata?) again
*** Implementation
The `name` attribute identifies the kind of tag, i.e. the tag's data type.
That means the `name` is not unique anymore, but the combination `name` + value is.
**** Worst, but easiest
One `name` column.
One attribute/column per possible data type.
***** Problems:
****** Each tag can only have one value, but how to ensure that?
****** Different tags with the same name must have the same type of value, but how to ensure that?
****** Adding a new data type requires a migration of the tag table and allowing users to add their own data types is out of the question.
**** Better
One `name` column.
One column for the data type, identifying the table that stores tag values of that type.
A second column for the Id of the entry in said table.
***** Problems:
****** Different tags with the same name must have the same type of value, but how to ensure that?
****** Adding a new data type requires… what? Adding a new table and a corresponding choice?
**** Better yet
One column for the tag type, i.e. name + data type.
Once column for the tag value.
** Auto-tagging
… could be implemented opportunistically in filters, scanners, fetchers etc.
*** could also be done based on other tag transitions
e.g. when the final episode in a season of a TV show is added, all the episodes in that season get the additional tag "complete season".
** Multilingual tags :i18n:
It should be possible to store tag names in different languages.
The different translations of a tag should be treated as the same tag, so a user should be shown only one tag, but in their desired language.
** Hookability
It should be possible to "hook" tag transitions, e.g. by registering callback functions or similar, so that a tag tansition may lead to system-specific actions.
** Logging
… built in facilities and/or simple way to export tag operation log data?
** Expiration
*** on `Tag` object?
essentially 'self-destruct'
*** on taggable object?
essentially 'remove_after…'
could be implemented as extra attribute on the ManyToMany relation
** Timestamps
*** Tag addition to or removal from object
could be implemented as extra attribute on the ManyToMany relation
** Tag synonyms
(cf. meta.stackexchange.com/tags/synonyms)
Useful in a large and/or evolving tag base. Mainly useful for search, I suppose.
Somewhat related to Multilingual tags, but the difference is that mutlilingual tags are different versions of the same tag, whereas tag synonyms are different tags that are treated as synonyms.
* Navigation
** UI elements
*** Tag cloud
*** TagTree
*** Tag Drawer
List of tags that can be pulled open from the side and contains a simple list of tags to allow dragging and dropping tags on objects.
** Filtering
*** ANDing & ORing
*** Tag selection by wildcards/regular expressions :structured_metadata_tags:
… probably mostly or only important for structured meta-data tags.
*** Tag selection by ranges :structured_metadata_tags:
… definitely only important for structured meta-data tags.
- Syntax?
** Sorting
*** Alphabetically by default :alphabetic_sorting:
**** considering the correct collation for the locale :i18n:
*** by ordering for mutually exclusive tags
… how can a user specify that?
*** by some ordering algorithm for structured meta-data tags :structured_metadata_tags:
**** although alphabetic sorting will often work in these cases :alphabetic_sorting:
** Aggregation :structured_metadata_tags:
E.g. The question "How many seasons of The Big Bang Theory are there (in the system)?" translates to "How many tags of class/form "season: …" are there, which are used together with the tag "the big bang theory"?
The question "Is Season X of The Big Bang Theory complete?" is more complicated, but it's solvable in several ways. Either by filtering by show title and season number and comparing the number of results with the highest episode number, or by having tags for "first episode in season", "following episode: <object>", (optionally "preceding episode: <other object>") and "last episode in season" and by checking whether the chain of following episodes is unbroken.
** Tag set theory with Venn diagrams
* Implementations
** Django app
*** How to separate Django app and (possible) Python library? :python_taggsonomy:
*** Auto-Fill Suggestions
… are indispensable for maintaining a controlled vocabulary.
They must take private/group/global tags into account.

Use <datalist> in default templatetag and replace with something fancier with JS.
*** Names
Tag names should support whitespace (well, at least single spaces), and be separated by commas, although the UI should turn that into visually separate entities.

To have nicely formatted tags in the input field as well as the auto-complete suggestion list will require JS.
*** Decorator
Implement decorator for taggable objects…
    `@taggsonomy.taggable`
… instead of "forcing" models to include a "tags" field?
*** TagSet…
A TagSet is a Model that (merely/mainly-?) wraps a ManyToManyRelation so it should behave like a ManyRelatedManager.

A ManyRelatedManager's `add` method accepts both object instances and object IDs as positional arguments, so TagSet.add should accept at least those, as well.

That means, though, that to check for mutual exclusions in the set of submitted tags, we have to do some work, to turn the positional arguments into a set of Tag objects, which is rather inefficient.
Since that is the case anyway, and since a Tag object is uniquely identified by it's name, we *can* also accept strings as positional arguments and resolve them to tags. When no tag by the name of a given string exists, a decision must be made whether to silently ignore it (no!), create a tag by that name, or treat it as an error.
Currently, I decide between the latter two options with the help of a keyword argument `create_nonexisting`, which defaults to False. This makes the code to handle those positional arguments inelegant  and, I suspect, slow, though, so I wonder whether this really is the way to got...
**** … as Descriptor
This *might* allow some syntatctic sugar like
    file.tags = ['foo', 'bar']
where file is an instance of a taggable model class, like:
    class File(models.Model):
        tags = OneToOne(TagSet, …)
`TagSet.__set__` could then make this essentially equivalent to:
    file.tags.add(['foo', 'bar'])

It's unclear whether that would work, though, as the relation is mediated by Django's `OneToOne` ModelField (which is probably a descriptor, itself).

If it *is* possible, this humble example can also be achieve with `property` (which itself returns descriptor objects).

Additionally, however, since the Descriptor protocol methods (`__get__`, `__set__` and `__delete__`) get the containing "parent" type or object passed into them, this could be used to implement some rather cool extra functionality, like the ability to look for and - if found - call specially named methods on that object.

So a taggable model could add custom behaviour by implementing such methods. That way, tagging could lead to actual object state changes.

This is not possible with `property` alone.
*** HTML(5)
**** UI elements (tag cloud, TagTree, TagDrawer etc.)
- should come as templatetags
- should render into <aside> elements?
**** Custom elements?
<tags>, <tag [user="…"] [group="…"]> etc.
*** Tag transition rules :transition_rules:
Tag exclusion is ManyToMany, so maybe add a `through=…` table, which would allow a Boolean attribute like `allow_replacment` or similar.
What about directionality?
*** TagTree-like URIs?
  E.g.:
"…/tags/foo/bar/baz/",
  … which would be equivalent to:
"…/tags/foo/baz/bar/",

** JS library
Maintain independently of Django app?
** Python library(?) :python_taggsonomy:
Pure Python, no Django ORM, therefore no assumption about persistence possible and object relations need to be handled Pythonically.
*** Everything is done in memory
Potentially very fast. Could be used by the Django app via aggregation, just need to make sure to update in-memory objects and DB atomically to avoid inconsistent states.
*** No state, essentially just mixin classes
Relies on certain state-exposing methods/attributes/properties to be present.
Would need to come up with a good, clean API that separates the two layers of functionality...
** Bookmarks (Browser extension) :bookmark_taggsonomy:
Written in JavaScript, HTML & CSS
Should target Firefox, Chromium & WebKit
** E-Mail
*** Thunderbird
*** IMAP
** Desktop application for overview?
with connectors to other local/remote implementations
** Online-Service for sync?
Would have to be zero knowledge!
